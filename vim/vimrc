runtime! plugins.vim
runtime! settings.vim

"
"--- PLUGIN CONFIGURATIONS
"

" colorscheme + powerline + airline
let g:airline_powerline_fonts=1

" gruvbox
let g:gruvbox_italic=1
let g:gruvbox_hls_cursor="blue"
let g:gruvbox_number_column="bg1"
let g:gruvbox_contrast_dark="hard"
let g:gruvbox_vert_split="bg4"
let g:gruvbox_color_column="bg4"
let g:gruvbox_guisp_fallback = "fg"
" Delete pipe characters on styling vertical split borders
set fillchars+=vert:\
colorscheme gruvbox
set background=dark

" Try to fix gruvbox color scheme for diffs
highlight! DiffDelete guifg=lightred ctermfg=lightred guibg=#32302f ctermbg=243 gui=inverse cterm=inverse
highlight! DiffAdd guifg=lightgreen ctermfg=lightgreen guibg=#32302f ctermbg=167 gui=inverse cterm=inverse
highlight! DiffChange guifg=gray ctermfg=gray guibg=#1d2021 ctermbg=229 gui=inverse cterm=inverse
highlight! DiffText guifg=lightblue ctermfg=136 guibg=#1d2021 ctermbg=229 gui=bold,inverse cterm=bold,inverse

" diff colorscheme: vim-colors-github
" set background=light
" use a slightly darker background, like GitHub inline code blocks
let g:github_colors_soft = 1
" more blocky diff markers in signcolumn (e.g. GitGutter)
let g:github_colors_block_diffmark = 0
" let g:airline_theme = "github"
" colorscheme github
" if &diff
"   colorscheme github
" endif

" " NERDTree
" let NERDTreeIgnore = ['\.pyc$', '\.swp$']
" let NERDTreeQuitOnOpen = 1
" nnoremap <leader>e :NERDTreeToggle<cr>

" ALE (Asynchronous Lint Engine)
" https://github.com/w0rp/ale
" let g:ale_linters = { 'python': ['flake8', 'pylint', 'mypy'], 'c': ['gcc', 'cppcheck'], 'cpp': ['gcc', 'cppcheck']}
let g:ale_linters = { 'python': ['flake8', 'pylint'], 'c': ['gcc', 'cppcheck'], 'cpp': ['gcc', 'cppcheck'], 'rust': ['analyzer']}
let g:ale_sign_column_always = 1
let g:ale_sign_error = '✗›'
let g:ale_sign_warning = '‼›'
let g:ale_sign_info = '∆›'
let g:ale_sign_style_error = '≈›'
let g:ale_sign_style_warning = '≈›'
let g:airline#extensions#ale#enabled = 1
let g:ale_open_list = 0  " 'on_save'
let g:ale_virtualenv_dir_names = ['venv', '.venv', '.py-env', '.py3-env', '.metis_env']
let g:ale_python_pylint_options = "--disable missing-docstring,line-too-long,invalid-name,too-many-arguments,too-many-instance-attributes,unnecessary-lambda,bad-whitespace,too-many-public-methods,too-few-public-methods,bad-continuation,too-many-locals"
" Annoying ALEExeption when viewing a diff with vim-fugitive
let g:ale_pattern_options = {'^fugitive:[\\/][\\/]': {'ale_enabled': 0}}
nmap <silent> ]e <Plug>(ale_next_wrap)
nmap <silent> [e <Plug>(ale_previous_wrap)
" For GCC
let g:ale_c_parse_compile_commands = 1
let g:ale_c_gcc_options = '-std=c11 -Wall -I$HOME/.pyenv/versions/3.7.4/include/python3.7m'
let g:ale_cpp_gcc_options = '-std=c++14 -Wall -I$HOME/.pyenv/versions/3.7.4/include/python3.7m'
let g:ale_c_clang_options = '-std=c11 -Wall -I$HOME/.pyenv/versions/3.7.4/include/python3.7m'
" let g:ale_c_gcc_options = '-std=c11 `python-config --cflags`'
" let g:ale_cpp_gcc_options = '-std=c++14 `python-config --cflags`'
" let g:ale_c_clang_options = '-std=c11 `python-config --cflags`'
let g:ale_c_clangd_executable = 'clangd'
let g:ale_c_clangd_options = ''
let g:ale_set_highlights = 0

" pymode plugin
" let g:pymode_python = 'python3'
let g:pymode_options_max_line_length = 120
let g:pymode_rope = 0
let g:pymode_rope_completion = 0
let g:pymode_rope_complete_on_dot = 0
let g:pymode_doc = 0
let g:pymode_lint = 0
let g:pymode_lint_checkers = ['pyflakes', 'mccabe']
let g:pymode_lint_ignore = "E731"
let g:pymode_lint_write = 0  " Auto check on save
let g:pymode_virtualenv = 0  " Support virtualenv
let g:pymode_breakpoint = 1  " Enable breakpoints plugin
let g:pymode_breakpoint_key = '<leader>b'
let g:pymode_breakpoint_cmd = 'import pudb; pudb.set_trace()  # BREAKPOINT'
let g:pymode_syntax = 1  " syntax highlighting
let g:pymode_syntax_all = 1
let g:pymode_syntax_indent_errors = g:pymode_syntax_all
let g:pymode_syntax_space_errors = g:pymode_syntax_all
let g:pymode_folding = 0  " Don't autofold code

" remote debugging with pudb
nmap <leader>rr Ofrom pudb.remote import set_trace; set_trace(term_size=(160, 48), host='0.0.0.0', port=6899)  # BREAKPOINT<esc>^

" Tabular
vmap <leader>t :Tabularize /

" " Deoplete
" let g:deoplete#enable_at_startup = 1
" let g:deoplete#enable_smart_case = 1
" " Use <tab> to complete words
" inoremap <silent><expr> <TAB> pumvisible() ? "\<C-n>" : <SID>check_back_space() ? "\<TAB>" : deoplete#mappings#manual_complete()
" function! s:check_back_space() abort
"     let col = col('.') - 1
"     return !col || getline('.')[col - 1]  =~ '\s'
" endfunction

" " Jedi vim
" " let g:jedi#force_py_version=3
" let g:jedi#show_call_signatures=2
" let g:jedi#auto_vim_configuration=0
" nnoremap <silent> <buffer> <leader>d :call jedi#goto()
" nnoremap <silent> <buffer> <K> :call jedi#show_documentation()
" nnoremap <silent> <buffer> <leader>n :call jedi#usages()

" YouCompletMe
let g:ycm_filetype_blacklist = {
      \ 'markdown': 1,
      \ 'netrw': 1,
      \ 'text': 1,
      \}
let g:ycm_language_server =
\ [
\   {
\     'name': 'rust',
\     'cmdline': ['rust-analyzer'],
\     'filetypes': ['rust'],
\     'project_root_files': ['Cargo.toml']
\   }
\ ]
" YCM's identifier completer will seed its identifier database with the keywords of the programming language you're writing
let g:ycm_seed_identifiers_with_syntax = 1
let g:ycm_add_preview_to_completeopt = 0
let g:ycm_use_clangd = 0
let g:ycm_global_ycm_extra_conf = '~/.vim/ycm_extra_conf.py'
let g:ycm_enable_diagnostic_highlighting=0
let g:ycm_auto_hover = ''
nnoremap <leader>d :YcmCompleter GoTo<cr>
nnoremap <leader>n :YcmCompleter GoToReferences<cr>
nnoremap <leader>h :YcmCompleter GetDoc<cr>

" Ack vim
if executable('rg')
    let g:ackprg = 'rg --vimgrep --no-heading'
elseif executable('ag')
    let g:ackprg = 'ag --vimgrep --smart-case'
endif
cnoreabbrev ag Ack!
cnoreabbrev Ag Ack!
"start a search query by pressing \
nnoremap \ :Ack!<space>
"search for word under cursor by pressing |
nnoremap \| :Ack! <C-R><C-W><cr>:cw<cr>

" fzf.vim
" see also entries in .zshrc where the fzf command is configured
nnoremap <c-p> :Files<cr>
nnoremap <leader>p :FZF<cr>


"
"-- KEY MAPPINGS
"

" quite a window
nnoremap <leader>q :q<cr>

" save current buffer (<C-s> gives problems in a normal linux terminal)
nnoremap <leader>w :w!<cr>

" yank to system clipboard
nnoremap <leader>y "+y

" paste from system clipboard
nmap <leader>p "+p

" make Y behave like C or D
nmap Y y$

" when searching center the search result in center of screen
nmap n nzz
nmap N Nzz

" insert a linebreak
nmap <leader>l i<cr><esc>

" treat long lines as break lines
map j gj
map k gk

" easier way to move between splits
map <C-h> <C-w>h
map <C-j> <C-w>j
map <C-k> <C-w>k
map <C-l> <C-w>l

" Blatantly stolen from https://github.com/tpope/vim-unimpaired/blob/master/plugin/unimpaired.vim

if exists("g:loaded_key_mappings") || &cp || v:version < 700
    finish
endif
let g:loaded_key_mappings = 1

" Next and previous

function! s:MapNextFamily(map,cmd)
    let map = '<Plug>unimpaired'.toupper(a:map)
    let cmd = '".(v:count ? v:count : "")."'.a:cmd
    let end = '"<CR>'.(a:cmd == 'l' || a:cmd == 'c' ? 'zv' : '')
    execute 'nnoremap <silent> '.map.'Previous :<C-U>exe "'.cmd.'previous'.end
    execute 'nnoremap <silent> '.map.'Next     :<C-U>exe "'.cmd.'next'.end
    execute 'nnoremap <silent> '.map.'First    :<C-U>exe "'.cmd.'first'.end
    execute 'nnoremap <silent> '.map.'Last     :<C-U>exe "'.cmd.'last'.end
    execute 'nmap <silent> ['.        a:map .' '.map.'Previous'
    execute 'nmap <silent> ]'.        a:map .' '.map.'Next'
    execute 'nmap <silent> ['.toupper(a:map).' '.map.'First'
    execute 'nmap <silent> ]'.toupper(a:map).' '.map.'Last'
    if exists(':'.a:cmd.'nfile')
        execute 'nnoremap <silent> '.map.'PFile :<C-U>exe "'.cmd.'pfile'.end
        execute 'nnoremap <silent> '.map.'NFile :<C-U>exe "'.cmd.'nfile'.end
        execute 'nmap <silent> [<C-'.a:map.'> '.map.'PFile'
        execute 'nmap <silent> ]<C-'.a:map.'> '.map.'NFile'
    endif
endfunction

" call s:MapNextFamily('a','')  " argument list
call s:MapNextFamily('b','b')  " buffer list
call s:MapNextFamily('l','l')  " local list
call s:MapNextFamily('q','c')  " quickfix list
call s:MapNextFamily('t','t')  " tag stack


" => Nifty trick found at https://sheerun.net/2014/03/21/how-to-boost-your-vim-productivity/
" select some text -> replace with "p" without overwritting the paste buffer!
" vp doesn't replace paste buffer
function! RestoreRegister()
  let @" = s:restore_reg
  return ''
endfunction
function! s:Repl()
  let s:restore_reg = @"
  return "p@=RestoreRegister()\<cr>"
endfunction
vmap <silent> <expr> p <sid>Repl()

" Define `Reverse`: reverses the order of the lines selected
command! -bar -range=% Reverse <line1>,<line2>global/^/m<line1>-1

" From https://vim.fandom.com/wiki/Pretty-formatting_XML
command! FormatXML :%!python3 -c "import xml.dom.minidom, sys; print(xml.dom.minidom.parse(sys.stdin).toprettyxml())"
command! FormatJson :%!python3 -m json.tool
